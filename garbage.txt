                    |   ID {
                    // if (searchSymbol(symbolTable, $1) == NULL) {
                    // yyerror("Undeclared variable used in assignment");
                    // }
                    }
{BEGIN} {
  return "BEGIN";
}
{END} {
  return "END";
}

{REAL} {
  (yylval.real = atof(yytext));
  return REAL;
}

"{"[^}]*"}"      /* Ignore comments enclosed in curly braces */
"BEGIN"  return BEGIN    ;
"END"    return END      ;
"INT"    return INT      ;
"FLOAT"  return FLOAT    ;
"BOOL"   return BOOL     ;
"CONST"  return CONST    ;
":"      return COLON    ;
";"      return SEMICOLON;
","      return COMMA    ;
"+"      return PLUS     ;
"-"      return MINUS    ;
"*"      return MULT     ;
"/"      return DIV      ;
"<"      return LESS     ;
">"      return GREATER  ;
"<>"     return NOTEQUAL ;
"<="     return LESSEQ   ;
">="     return GREATEQ  ;
"=="     return EQUAL    ;
"!"      return NOT      ;
":="     return ASSIGN_OP;
"for"    return FOR      ;
"if"     return IF       ;
"else"   return ELSE     ;

# nested vs non-nested
conditional_ins:             conditional_ins_nested | conditional_ins_simple;
conditional_ins_simple: if_statement_simple | if_else_statement_simple;
if_statement_simple:   if_statement_head if_statement_body;
if_statement_head:        IF condition;
if_statement_body:        BRACKET_OPEN assign_or_loop_ins_list BRACKET_CLOSE;
if_else_statement_simple:  if_statement_simple else_statement_simple;
else_statement_simple:  ELSE BRACKET_OPEN assign_or_loop_ins_list BRACKET_CLOSE;
assign_or_loop_ins_list:  assign_ins_list | for_loop_ins_list;

conditional_ins_nested: if_statement_nested | if_else_statement_nested;
if_statement_nested: if_statement_head if_statement_body_nested;
if_statement_body_nested:        BRACKET_OPEN instruction_list BRACKET_CLOSE;
if_else_statement_nested: if_statement_nested else_statement_nested;
else_statement_nested:    ELSE BRACKET_OPEN instruction_list BRACKET_CLOSE;
#####
for_loop_ins: for_loop_ins_simple | for_loop_ins_complex;

for_loop_ins_simple:            for_loop_head for_loop_body_simple;
for_loop_ins_complex:           for_loop_head for_loop_body_complex;
for_loop_head:           FOR PARENTH_OPEN assign_ins_int COMMA condition COMMA assign_ins_int PARENTH_CLOSE;
                        | FOR PARENTH_OPEN assign_ins_int error condition error assign_ins_int PARENTH_CLOSE
                            { yyerror("Missing COMMAS in forloop head"); }
for_loop_body_simple:           BRACKET_OPEN assign_or_conditional_ins_list BRACKET_CLOSE  ;

assign_or_conditional_ins_list: assign_ins_list | conditional_ins_list;

for_loop_body_complex:      BRACKET_OPEN instruction_list BRACKET_CLOSE;
####
counter: ID PLUS PLUS { checkCounterID($1); /* handle i++ */ }
       | ID MINUS MINUS { checkCounterID($1); /* handle i-- */ }
       | ID ASSIGN_OP ID { checkCounterID($1); /* handle i := j */ }
       | ID ASSIGN_OP ID MULT ID { checkCounterID($1); /* handle i := j * k */ }
       | ID ASSIGN_OP ID DIV ID  { checkCounterID($1); /* handle i := j / k */ }
       | ID ASSIGN_OP INTEGER { checkCounterID($1); /* handle i := 5 */ }
       | error { yyerror("inappropriate counter in forloop");} 
;
void checkCounterID(char* id) {
    if (strcmp(id, storedID) != 0) {
        fprintf(stderr, "Semantic error: Counter ID '%s' does not match loop head ID '%s'\n", id, storedID);
    }
}